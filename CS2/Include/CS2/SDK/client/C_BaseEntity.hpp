// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/entity2/CEntityInstance.hpp>
#include <SDK/client/CNetworkTransmitComponent.hpp>
#include <SDK/entity2/GameTick_t.hpp>
#include <SDK/client/TakeDamageFlags_t.hpp>
#include <SDK/client/EntityPlatformTypes_t.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/client/CNetworkVelocityVector.hpp>
#include <SDK/client/MoveCollide_t.hpp>
#include <SDK/client/MoveType_t.hpp>
#include <SDK/particleslib/CParticleProperty.hpp>
#include <SDK/client/BloodType.hpp>



namespace CS2 {
	namespace client {
		class CBodyComponent;
		class CGameSceneNode;
		class CRenderComponent;
		class CCollisionProperty;
		class thinkfunc_t;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace client {
		class C_BaseEntity : public CS2::entity2::CEntityInstance {
		public:
			PROPERTY(m_CBodyComponent,client::CBodyComponent* , 0x38);
			PROPERTY(m_NetworkTransmitComponent,client::CNetworkTransmitComponent , 0x40);
			PROPERTY(m_nLastThinkTick,entity2::GameTick_t , 0x328);
			PROPERTY(m_pGameSceneNode,client::CGameSceneNode* , 0x330);
			PROPERTY(m_pRenderComponent,client::CRenderComponent* , 0x338);
			PROPERTY(m_pCollision,client::CCollisionProperty* , 0x340);
			PROPERTY(m_iMaxHealth,int32_t , 0x348);
			PROPERTY(m_iHealth,int32_t , 0x34c);
			PROPERTY(m_flDamageAccumulator,float32 , 0x350);
			PROPERTY(m_lifeState,uint8_t , 0x354);
			PROPERTY(m_bTakesDamage,bool , 0x355);
			PROPERTY(m_nTakeDamageFlags,client::TakeDamageFlags_t , 0x358);
			PROPERTY(m_nPlatformType,client::EntityPlatformTypes_t , 0x360);
			PROPERTY(m_ubInterpolationFrame,uint8_t , 0x361);
			PROPERTY(m_hSceneObjectController,GlobalTypes::CHandle<client::C_BaseEntity>, 0x364);
			PROPERTY(m_nNoInterpolationTick,int32_t , 0x368);
			PROPERTY(m_nVisibilityNoInterpolationTick,int32_t , 0x36c);
			PROPERTY(m_flProxyRandomValue,float32 , 0x370);
			PROPERTY(m_iEFlags,int32_t , 0x374);
			PROPERTY(m_nWaterType,uint8_t , 0x378);
			PROPERTY(m_bInterpolateEvenWithNoModel,bool , 0x379);
			PROPERTY(m_bPredictionEligible,bool , 0x37a);
			PROPERTY(m_bApplyLayerMatchIDToModel,bool , 0x37b);
			PROPERTY(m_tokLayerMatchID,GlobalTypes::CUtlStringToken* , 0x37c);
			PROPERTY(m_nSubclassID,GlobalTypes::CUtlStringToken* , 0x380);
			PROPERTY(m_nSimulationTick,int32_t , 0x390);
			PROPERTY(m_iCurrentThinkContext,int32_t , 0x394);
			PROPERTY(m_aThinkFunctions,GlobalTypes::CUtlVector<client::thinkfunc_t>, 0x398);
			PROPERTY(m_bDisabledContextThinks,bool , 0x3b0);
			PROPERTY(m_flAnimTime,float32 , 0x3b4);
			PROPERTY(m_flSimulationTime,float32 , 0x3b8);
			PROPERTY(m_nSceneObjectOverrideFlags,uint8_t , 0x3bc);
			PROPERTY(m_bHasSuccessfullyInterpolated,bool , 0x3bd);
			PROPERTY(m_bHasAddedVarsToInterpolation,bool , 0x3be);
			PROPERTY(m_bRenderEvenWhenNotSuccessfullyInterpolated,bool , 0x3bf);
			PROPERTY_ARRAY(m_nInterpolationLatchDirtyFlags,int32_t , 2 , 0x3c0);
			PROPERTY_ARRAY(m_ListEntry,uint16_t , 11 , 0x3c8);
			PROPERTY(m_flCreateTime,entity2::GameTime_t , 0x3e0);
			PROPERTY(m_flSpeed,float32 , 0x3e4);
			PROPERTY(m_EntClientFlags,uint16_t , 0x3e8);
			PROPERTY(m_bClientSideRagdoll,bool , 0x3ea);
			PROPERTY(m_iTeamNum,uint8_t , 0x3eb);
			PROPERTY(m_spawnflags,uint32_t , 0x3ec);
			PROPERTY(m_nNextThinkTick,entity2::GameTick_t , 0x3f0);
			PROPERTY(m_fFlags,uint32_t , 0x3f8);
			PROPERTY(m_vecAbsVelocity,GlobalTypes::Vector , 0x3fc);
			PROPERTY(m_vecServerVelocity,client::CNetworkVelocityVector , 0x408);
			PROPERTY(m_vecVelocity,client::CNetworkVelocityVector , 0x430);
			PROPERTY(m_vecBaseVelocity,GlobalTypes::Vector , 0x510);
			PROPERTY(m_hEffectEntity,GlobalTypes::CHandle<client::C_BaseEntity>, 0x51c);
			PROPERTY(m_hOwnerEntity,GlobalTypes::CHandle<client::C_BaseEntity>, 0x520);
			PROPERTY(m_MoveCollide,client::MoveCollide_t , 0x524);
			PROPERTY(m_MoveType,client::MoveType_t , 0x525);
			PROPERTY(m_nActualMoveType,client::MoveType_t , 0x526);
			PROPERTY(m_flWaterLevel,float32 , 0x528);
			PROPERTY(m_fEffects,uint32_t , 0x52c);
			PROPERTY(m_hGroundEntity,GlobalTypes::CHandle<client::C_BaseEntity>, 0x530);
			PROPERTY(m_nGroundBodyIndex,int32_t , 0x534);
			PROPERTY(m_flFriction,float32 , 0x538);
			PROPERTY(m_flElasticity,float32 , 0x53c);
			PROPERTY(m_flGravityScale,float32 , 0x540);
			PROPERTY(m_flTimeScale,float32 , 0x544);
			PROPERTY(m_bAnimatedEveryTick,bool , 0x548);
			PROPERTY(m_bGravityDisabled,bool , 0x549);
			PROPERTY(m_flNavIgnoreUntilTime,entity2::GameTime_t , 0x54c);
			PROPERTY(m_hThink,uint16_t , 0x550);
			PROPERTY(m_fBBoxVisFlags,uint8_t , 0x560);
			PROPERTY(m_flActualGravityScale,float32 , 0x564);
			PROPERTY(m_bGravityActuallyDisabled,bool , 0x568);
			PROPERTY(m_bPredictable,bool , 0x569);
			PROPERTY(m_bRenderWithViewModels,bool , 0x56a);
			PROPERTY(m_nFirstPredictableCommand,int32_t , 0x56c);
			PROPERTY(m_nLastPredictableCommand,int32_t , 0x570);
			PROPERTY(m_hOldMoveParent,GlobalTypes::CHandle<client::C_BaseEntity>, 0x574);
			PROPERTY(m_Particles,particleslib::CParticleProperty , 0x578);
			PROPERTY(m_vecAngVelocity,GlobalTypes::QAngle , 0x5a8);
			PROPERTY(m_DataChangeEventRef,int32_t , 0x5b4);
			PROPERTY(m_dependencies,GlobalTypes::CUtlVector<GlobalTypes::CEntityHandle>, 0x5b8);
			PROPERTY(m_nCreationTick,int32_t , 0x5d0);
			PROPERTY(m_bAnimTimeChanged,bool , 0x5dd);
			PROPERTY(m_bSimulationTimeChanged,bool , 0x5de);
			PROPERTY(m_sUniqueHammerID,GlobalTypes::CUtlString* , 0x5e8);
			PROPERTY(m_nBloodType,client::BloodType , 0x5f0);
			S2_PAD(0x5C0);
		};
		//static_assert(sizeof(CS2::client::C_BaseEntity) == 0x5F8, "C_BaseEntity size should be 0x5F8");
	}
}
