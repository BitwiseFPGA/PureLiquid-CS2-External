// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/server/CBaseModelEntity.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/entity2/CEntityIOOutput.hpp>
#include <SDK/server/Rotate_t.hpp>
#include <SDK/server/RotatorTargetSpace_t.hpp>



namespace CS2 {
	namespace server {
		class CBaseEntity;
		class RotatorHistoryEntry_t;
		class RotatorQueueEntry_t;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace server {
		class CFuncRotator : public CS2::server::CBaseModelEntity {
		public:
			PROPERTY(m_hRotatorTarget,GlobalTypes::CHandle<server::CBaseEntity>, 0x7d8);
			PROPERTY(m_bIsRotating,bool , 0x7dc);
			PROPERTY(m_bIsReversing,bool , 0x7dd);
			PROPERTY(m_flTimeToReachMaxSpeed,float32 , 0x7e0);
			PROPERTY(m_flTimeToReachZeroSpeed,float32 , 0x7e4);
			PROPERTY(m_flDistanceAlongArcTraveled,float32 , 0x7e8);
			PROPERTY(m_flTimeToWaitOscillate,float32 , 0x7ec);
			PROPERTY(m_flTimeRotationStart,entity2::GameTime_t , 0x7f0);
			PROPERTY(m_qLSPrevChange,GlobalTypes::Quaternion , 0x800);
			PROPERTY(m_qWSPrev,GlobalTypes::Quaternion , 0x810);
			PROPERTY(m_qWSInit,GlobalTypes::Quaternion , 0x820);
			PROPERTY(m_qLSInit,GlobalTypes::Quaternion , 0x830);
			PROPERTY(m_qLSOrientation,GlobalTypes::Quaternion , 0x840);
			PROPERTY(m_OnRotationStarted,entity2::CEntityIOOutput , 0x850);
			PROPERTY(m_OnRotationCompleted,entity2::CEntityIOOutput , 0x878);
			PROPERTY(m_OnOscillate,entity2::CEntityIOOutput , 0x8a0);
			PROPERTY(m_OnOscillateStartArrive,entity2::CEntityIOOutput , 0x8c8);
			PROPERTY(m_OnOscillateStartDepart,entity2::CEntityIOOutput , 0x8f0);
			PROPERTY(m_OnOscillateEndArrive,entity2::CEntityIOOutput , 0x918);
			PROPERTY(m_OnOscillateEndDepart,entity2::CEntityIOOutput , 0x940);
			PROPERTY(m_bOscillateDepart,bool , 0x968);
			PROPERTY(m_nOscillateCount,int32_t , 0x96c);
			PROPERTY(m_eRotateType,server::Rotate_t , 0x970);
			PROPERTY(m_ePrevRotateType,server::Rotate_t , 0x974);
			PROPERTY(m_bHasTargetOverride,bool , 0x978);
			PROPERTY(m_qOrientationOverride,GlobalTypes::Quaternion , 0x980);
			PROPERTY(m_eSpaceOverride,server::RotatorTargetSpace_t , 0x990);
			PROPERTY(m_qAngularVelocity,GlobalTypes::QAngle , 0x994);
			PROPERTY(m_vLookAtForcedUp,GlobalTypes::Vector , 0x9a0);
			PROPERTY(m_strRotatorTarget,GlobalTypes::CUtlSymbolLarge* , 0x9b0);
			PROPERTY(m_bRecordHistory,bool , 0x9b8);
			PROPERTY(m_vecRotatorHistory,GlobalTypes::CUtlVector<server::RotatorHistoryEntry_t>, 0x9c0);
			PROPERTY(m_bReturningToPreviousOrientation,bool , 0x9d8);
			PROPERTY(m_vecRotatorQueue,GlobalTypes::CUtlVector<server::RotatorQueueEntry_t>, 0x9e0);
			PROPERTY(m_vecRotatorQueueHistory,GlobalTypes::CUtlVector<server::RotatorHistoryEntry_t>, 0x9f8);
			S2_PAD(0x238);
		};
		//static_assert(sizeof(CS2::server::CFuncRotator) == 0xA10, "CFuncRotator size should be 0xA10");
	}
}
