// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/server/CBot.hpp>
#include <SDK/server/CountdownTimer.hpp>
#include <SDK/server/IntervalTimer.hpp>
#include <SDK/entity2/GameTime_t.hpp>



namespace CS2 {
	namespace server {
		class CCSPlayerPawn;
		class CBaseEntity;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace server {
		class CCSBot : public CS2::server::CBot {
		public:
			PROPERTY(m_eyePosition,GlobalTypes::VectorWS , 0x108);
			PROPERTY_ARRAY(m_name,char , 64 , 0x114);
			PROPERTY(m_combatRange,float32 , 0x154);
			PROPERTY(m_isRogue,bool , 0x158);
			PROPERTY(m_rogueTimer,server::CountdownTimer , 0x160);
			PROPERTY(m_diedLastRound,bool , 0x17c);
			PROPERTY(m_safeTime,float32 , 0x180);
			PROPERTY(m_wasSafe,bool , 0x184);
			PROPERTY(m_blindFire,bool , 0x18c);
			PROPERTY(m_surpriseTimer,server::CountdownTimer , 0x190);
			PROPERTY(m_bAllowActive,bool , 0x1a8);
			PROPERTY(m_isFollowing,bool , 0x1a9);
			PROPERTY(m_leader,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x1ac);
			PROPERTY(m_followTimestamp,float32 , 0x1b0);
			PROPERTY(m_allowAutoFollowTime,float32 , 0x1b4);
			PROPERTY(m_hurryTimer,server::CountdownTimer , 0x1b8);
			PROPERTY(m_alertTimer,server::CountdownTimer , 0x1d0);
			PROPERTY(m_sneakTimer,server::CountdownTimer , 0x1e8);
			PROPERTY(m_panicTimer,server::CountdownTimer , 0x200);
			PROPERTY(m_stateTimestamp,float32 , 0x578);
			PROPERTY(m_isAttacking,bool , 0x57c);
			PROPERTY(m_isOpeningDoor,bool , 0x57d);
			PROPERTY(m_taskEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x584);
			PROPERTY(m_goalPosition,GlobalTypes::VectorWS , 0x594);
			PROPERTY(m_goalEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x5a0);
			PROPERTY(m_avoid,GlobalTypes::CHandle<server::CBaseEntity>, 0x5a4);
			PROPERTY(m_avoidTimestamp,float32 , 0x5a8);
			PROPERTY(m_isStopping,bool , 0x5ac);
			PROPERTY(m_hasVisitedEnemySpawn,bool , 0x5ad);
			PROPERTY(m_stillTimer,server::IntervalTimer , 0x5b0);
			PROPERTY(m_bEyeAnglesUnderPathFinderControl,bool , 0x5c0);
			PROPERTY(m_pathIndex,int32_t , 0x5ec0);
			PROPERTY(m_areaEnteredTimestamp,entity2::GameTime_t , 0x5ec4);
			PROPERTY(m_repathTimer,server::CountdownTimer , 0x5ec8);
			PROPERTY(m_avoidFriendTimer,server::CountdownTimer , 0x5ee0);
			PROPERTY(m_isFriendInTheWay,bool , 0x5ef8);
			PROPERTY(m_politeTimer,server::CountdownTimer , 0x5f00);
			PROPERTY(m_isWaitingBehindFriend,bool , 0x5f18);
			PROPERTY(m_pathLadderEnd,float32 , 0x5f44);
			PROPERTY(m_mustRunTimer,server::CountdownTimer , 0x5f90);
			PROPERTY(m_waitTimer,server::CountdownTimer , 0x5fa8);
			PROPERTY(m_updateTravelDistanceTimer,server::CountdownTimer , 0x5fc0);
			PROPERTY_ARRAY(m_playerTravelDistance,float32 , 64 , 0x5fd8);
			PROPERTY(m_travelDistancePhase,uint8_t , 0x60d8);
			PROPERTY(m_hostageEscortCount,uint8_t , 0x6270);
			PROPERTY(m_hostageEscortCountTimestamp,float32 , 0x6274);
			PROPERTY(m_desiredTeam,int32_t , 0x6278);
			PROPERTY(m_hasJoined,bool , 0x627c);
			PROPERTY(m_isWaitingForHostage,bool , 0x627d);
			PROPERTY(m_inhibitWaitingForHostageTimer,server::CountdownTimer , 0x6280);
			PROPERTY(m_waitForHostageTimer,server::CountdownTimer , 0x6298);
			PROPERTY(m_noisePosition,GlobalTypes::Vector , 0x62b0);
			PROPERTY(m_noiseTravelDistance,float32 , 0x62bc);
			PROPERTY(m_noiseTimestamp,float32 , 0x62c0);
			PROPERTY(m_noiseSource,server::CCSPlayerPawn* , 0x62c8);
			PROPERTY(m_noiseBendTimer,server::CountdownTimer , 0x62e0);
			PROPERTY(m_bentNoisePosition,GlobalTypes::Vector , 0x62f8);
			PROPERTY(m_bendNoisePositionValid,bool , 0x6304);
			PROPERTY(m_lookAroundStateTimestamp,float32 , 0x6308);
			PROPERTY(m_lookAheadAngle,float32 , 0x630c);
			PROPERTY(m_forwardAngle,float32 , 0x6310);
			PROPERTY(m_inhibitLookAroundTimestamp,float32 , 0x6314);
			PROPERTY(m_lookAtSpot,GlobalTypes::Vector , 0x631c);
			PROPERTY(m_lookAtSpotDuration,float32 , 0x632c);
			PROPERTY(m_lookAtSpotTimestamp,float32 , 0x6330);
			PROPERTY(m_lookAtSpotAngleTolerance,float32 , 0x6334);
			PROPERTY(m_lookAtSpotClearIfClose,bool , 0x6338);
			PROPERTY(m_lookAtSpotAttack,bool , 0x6339);
			PROPERTY(m_lookAtDesc,char* , 0x6340);
			PROPERTY(m_peripheralTimestamp,float32 , 0x6348);
			PROPERTY(m_approachPointCount,uint8_t , 0x64d0);
			PROPERTY(m_approachPointViewPosition,GlobalTypes::Vector , 0x64d4);
			PROPERTY(m_viewSteadyTimer,server::IntervalTimer , 0x64e0);
			PROPERTY(m_tossGrenadeTimer,server::CountdownTimer , 0x64f8);
			PROPERTY(m_isAvoidingGrenade,server::CountdownTimer , 0x6518);
			PROPERTY(m_spotCheckTimestamp,float32 , 0x6538);
			PROPERTY(m_checkedHidingSpotCount,int32_t , 0x6940);
			PROPERTY(m_lookPitch,float32 , 0x6944);
			PROPERTY(m_lookPitchVel,float32 , 0x6948);
			PROPERTY(m_lookYaw,float32 , 0x694c);
			PROPERTY(m_lookYawVel,float32 , 0x6950);
			PROPERTY(m_targetSpot,GlobalTypes::Vector , 0x6954);
			PROPERTY(m_targetSpotVelocity,GlobalTypes::Vector , 0x6960);
			PROPERTY(m_targetSpotPredicted,GlobalTypes::Vector , 0x696c);
			PROPERTY(m_aimError,GlobalTypes::QAngle , 0x6978);
			PROPERTY(m_aimGoal,GlobalTypes::QAngle , 0x6984);
			PROPERTY(m_targetSpotTime,entity2::GameTime_t , 0x6990);
			PROPERTY(m_aimFocus,float32 , 0x6994);
			PROPERTY(m_aimFocusInterval,float32 , 0x6998);
			PROPERTY(m_aimFocusNextUpdate,entity2::GameTime_t , 0x699c);
			PROPERTY(m_ignoreEnemiesTimer,server::CountdownTimer , 0x69a8);
			PROPERTY(m_enemy,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x69c0);
			PROPERTY(m_isEnemyVisible,bool , 0x69c4);
			PROPERTY(m_visibleEnemyParts,uint8_t , 0x69c5);
			PROPERTY(m_lastEnemyPosition,GlobalTypes::Vector , 0x69c8);
			PROPERTY(m_lastSawEnemyTimestamp,float32 , 0x69d4);
			PROPERTY(m_firstSawEnemyTimestamp,float32 , 0x69d8);
			PROPERTY(m_currentEnemyAcquireTimestamp,float32 , 0x69dc);
			PROPERTY(m_enemyDeathTimestamp,float32 , 0x69e0);
			PROPERTY(m_friendDeathTimestamp,float32 , 0x69e4);
			PROPERTY(m_isLastEnemyDead,bool , 0x69e8);
			PROPERTY(m_nearbyEnemyCount,int32_t , 0x69ec);
			PROPERTY(m_bomber,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x6bf8);
			PROPERTY(m_nearbyFriendCount,int32_t , 0x6bfc);
			PROPERTY(m_closestVisibleFriend,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x6c00);
			PROPERTY(m_closestVisibleHumanFriend,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x6c04);
			PROPERTY(m_attentionInterval,server::IntervalTimer , 0x6c08);
			PROPERTY(m_attacker,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x6c18);
			PROPERTY(m_attackedTimestamp,float32 , 0x6c1c);
			PROPERTY(m_burnedByFlamesTimer,server::IntervalTimer , 0x6c20);
			PROPERTY(m_lastVictimID,int32_t , 0x6c30);
			PROPERTY(m_isAimingAtEnemy,bool , 0x6c34);
			PROPERTY(m_isRapidFiring,bool , 0x6c35);
			PROPERTY(m_equipTimer,server::IntervalTimer , 0x6c38);
			PROPERTY(m_zoomTimer,server::CountdownTimer , 0x6c48);
			PROPERTY(m_fireWeaponTimestamp,entity2::GameTime_t , 0x6c60);
			PROPERTY(m_lookForWeaponsOnGroundTimer,server::CountdownTimer , 0x6c68);
			PROPERTY(m_bIsSleeping,bool , 0x6c80);
			PROPERTY(m_isEnemySniperVisible,bool , 0x6c81);
			PROPERTY(m_sawEnemySniperTimer,server::CountdownTimer , 0x6c88);
			PROPERTY(m_enemyQueueIndex,uint8_t , 0x6d40);
			PROPERTY(m_enemyQueueCount,uint8_t , 0x6d41);
			PROPERTY(m_enemyQueueAttendIndex,uint8_t , 0x6d42);
			PROPERTY(m_isStuck,bool , 0x6d43);
			PROPERTY(m_stuckTimestamp,entity2::GameTime_t , 0x6d44);
			PROPERTY(m_stuckSpot,GlobalTypes::Vector , 0x6d48);
			PROPERTY(m_wiggleTimer,server::CountdownTimer , 0x6d58);
			PROPERTY(m_stuckJumpTimer,server::CountdownTimer , 0x6d70);
			PROPERTY(m_nextCleanupCheckTimestamp,entity2::GameTime_t , 0x6d88);
			PROPERTY_ARRAY(m_avgVel,float32 , 10 , 0x6d8c);
			PROPERTY(m_avgVelIndex,int32_t , 0x6db4);
			PROPERTY(m_avgVelCount,int32_t , 0x6db8);
			PROPERTY(m_lastOrigin,GlobalTypes::Vector , 0x6dbc);
			PROPERTY(m_lastRadioRecievedTimestamp,float32 , 0x6dcc);
			PROPERTY(m_lastRadioSentTimestamp,float32 , 0x6dd0);
			PROPERTY(m_radioSubject,GlobalTypes::CHandle<server::CCSPlayerPawn>, 0x6dd4);
			PROPERTY(m_radioPosition,GlobalTypes::Vector , 0x6dd8);
			PROPERTY(m_voiceEndTimestamp,float32 , 0x6de4);
			PROPERTY(m_lastValidReactionQueueFrame,int32_t , 0x6df0);
			S2_PAD(0x6CF8);
		};
		//static_assert(sizeof(CS2::server::CCSBot) == 0x6DF8, "CCSBot size should be 0x6DF8");
	}
}
