// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/server/CBaseEntity.hpp>
#include <SDK/modellib/ScriptedMoveTo_t.hpp>
#include <SDK/modellib/SharedMovementGait_t.hpp>
#include <SDK/modellib/ScriptedHeldWeaponBehavior_t.hpp>
#include <SDK/client/ForcedCrouchState_t.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/client/ScriptedOnDeath_t.hpp>
#include <SDK/server/ScriptedConflictResponse_t.hpp>
#include <SDK/entity2/CEntityIOOutput.hpp>



namespace CS2 {
	namespace server {
		class CBaseAnimGraph;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace server {
		class CScriptedSequence : public CS2::server::CBaseEntity {
		public:
			PROPERTY(m_iszEntry,GlobalTypes::CUtlSymbolLarge* , 0x4f0);
			PROPERTY(m_iszPreIdle,GlobalTypes::CUtlSymbolLarge* , 0x4f8);
			PROPERTY(m_iszPlay,GlobalTypes::CUtlSymbolLarge* , 0x500);
			PROPERTY(m_iszPostIdle,GlobalTypes::CUtlSymbolLarge* , 0x508);
			PROPERTY(m_iszModifierToAddOnPlay,GlobalTypes::CUtlSymbolLarge* , 0x510);
			PROPERTY(m_iszNextScript,GlobalTypes::CUtlSymbolLarge* , 0x518);
			PROPERTY(m_iszEntity,GlobalTypes::CUtlSymbolLarge* , 0x520);
			PROPERTY(m_iszSyncGroup,GlobalTypes::CUtlSymbolLarge* , 0x528);
			PROPERTY(m_nMoveTo,modellib::ScriptedMoveTo_t , 0x530);
			PROPERTY(m_nMoveToGait,modellib::SharedMovementGait_t , 0x534);
			PROPERTY(m_nHeldWeaponBehavior,modellib::ScriptedHeldWeaponBehavior_t , 0x538);
			PROPERTY(m_nForcedCrouchState,client::ForcedCrouchState_t , 0x53c);
			PROPERTY(m_bIsPlayingPreIdle,bool , 0x540);
			PROPERTY(m_bIsPlayingEntry,bool , 0x541);
			PROPERTY(m_bIsPlayingAction,bool , 0x542);
			PROPERTY(m_bIsPlayingPostIdle,bool , 0x543);
			PROPERTY(m_bDontRotateOther,bool , 0x544);
			PROPERTY(m_bIsRepeatable,bool , 0x545);
			PROPERTY(m_bShouldLeaveCorpse,bool , 0x546);
			PROPERTY(m_bStartOnSpawn,bool , 0x547);
			PROPERTY(m_bDisallowInterrupts,bool , 0x548);
			PROPERTY(m_bCanOverrideNPCState,bool , 0x549);
			PROPERTY(m_bDontTeleportAtEnd,bool , 0x54a);
			PROPERTY(m_bHighPriority,bool , 0x54b);
			PROPERTY(m_bHideDebugComplaints,bool , 0x54c);
			PROPERTY(m_bContinueOnDeath,bool , 0x54d);
			PROPERTY(m_bLoopPreIdleSequence,bool , 0x54e);
			PROPERTY(m_bLoopActionSequence,bool , 0x54f);
			PROPERTY(m_bLoopPostIdleSequence,bool , 0x550);
			PROPERTY(m_bSynchPostIdles,bool , 0x551);
			PROPERTY(m_bIgnoreLookAt,bool , 0x552);
			PROPERTY(m_bIgnoreGravity,bool , 0x553);
			PROPERTY(m_bDisableNPCCollisions,bool , 0x554);
			PROPERTY(m_bKeepAnimgraphLockedPost,bool , 0x555);
			PROPERTY(m_bDontAddModifiers,bool , 0x556);
			PROPERTY(m_bDisableAimingWhileMoving,bool , 0x557);
			PROPERTY(m_bIgnoreRotation,bool , 0x558);
			PROPERTY(m_flRadius,float32 , 0x55c);
			PROPERTY(m_flRepeat,float32 , 0x560);
			PROPERTY(m_flPlayAnimFadeInTime,float32 , 0x564);
			PROPERTY(m_flMoveInterpTime,float32 , 0x568);
			PROPERTY(m_flAngRate,float32 , 0x56c);
			PROPERTY(m_flMoveSpeed,float32 , 0x570);
			PROPERTY(m_bWaitUntilMoveCompletesToStartAnimation,bool , 0x574);
			PROPERTY(m_nNotReadySequenceCount,int32_t , 0x578);
			PROPERTY(m_startTime,entity2::GameTime_t , 0x57c);
			PROPERTY(m_bWaitForBeginSequence,bool , 0x580);
			PROPERTY(m_saved_effects,int32_t , 0x584);
			PROPERTY(m_savedFlags,int32_t , 0x588);
			PROPERTY(m_savedCollisionGroup,int32_t , 0x58c);
			PROPERTY(m_bInterruptable,bool , 0x590);
			PROPERTY(m_sequenceStarted,bool , 0x591);
			PROPERTY(m_bPositionRelativeToOtherEntity,bool , 0x592);
			PROPERTY(m_hTargetEnt,GlobalTypes::CHandle<server::CBaseEntity>, 0x594);
			PROPERTY(m_hNextCine,GlobalTypes::CHandle<server::CScriptedSequence>, 0x598);
			PROPERTY(m_bThinking,bool , 0x59c);
			PROPERTY(m_bInitiatedSelfDelete,bool , 0x59d);
			PROPERTY(m_bIsTeleportingDueToMoveTo,bool , 0x59e);
			PROPERTY(m_bAllowCustomInterruptConditions,bool , 0x59f);
			PROPERTY(m_hForcedTarget,GlobalTypes::CHandle<server::CBaseAnimGraph>, 0x5a0);
			PROPERTY(m_bDontCancelOtherSequences,bool , 0x5a4);
			PROPERTY(m_bForceSynch,bool , 0x5a5);
			PROPERTY(m_bPreventUpdateYawOnFinish,bool , 0x5a6);
			PROPERTY(m_bEnsureOnNavmeshOnFinish,bool , 0x5a7);
			PROPERTY(m_onDeathBehavior,client::ScriptedOnDeath_t , 0x5a8);
			PROPERTY(m_ConflictResponse,server::ScriptedConflictResponse_t , 0x5ac);
			PROPERTY(m_OnBeginSequence,entity2::CEntityIOOutput , 0x5b0);
			PROPERTY(m_OnActionStartOrLoop,entity2::CEntityIOOutput , 0x5d8);
			PROPERTY(m_OnEndSequence,entity2::CEntityIOOutput , 0x600);
			PROPERTY(m_OnPostIdleEndSequence,entity2::CEntityIOOutput , 0x628);
			PROPERTY(m_OnCancelSequence,entity2::CEntityIOOutput , 0x650);
			PROPERTY(m_OnCancelFailedSequence,entity2::CEntityIOOutput , 0x678);
			PROPERTY_ARRAY(m_OnScriptEvent,entity2::CEntityIOOutput , 8 , 0x6a0);
			PROPERTY(m_matOtherToMain,GlobalTypes::CTransform , 0x7e0);
			PROPERTY(m_hInteractionMainEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x800);
			PROPERTY(m_iPlayerDeathBehavior,int32_t , 0x804);
			PROPERTY(m_bSkipFadeIn,bool , 0x808);
			S2_PAD(0x320);
		};
		//static_assert(sizeof(CS2::server::CScriptedSequence) == 0x810, "CScriptedSequence size should be 0x810");
	}
}
