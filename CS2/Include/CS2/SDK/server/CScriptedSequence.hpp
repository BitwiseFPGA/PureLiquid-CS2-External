// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/server/CBaseEntity.hpp>
#include <SDK/modellib/ScriptedMoveTo_t.hpp>
#include <SDK/modellib/SharedMovementGait_t.hpp>
#include <SDK/modellib/ScriptedHeldWeaponBehavior_t.hpp>
#include <SDK/client/ForcedCrouchState_t.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/client/ScriptedOnDeath_t.hpp>
#include <SDK/server/ScriptedConflictResponse_t.hpp>
#include <SDK/entity2/CEntityIOOutput.hpp>



namespace CS2 {
	namespace server {
		class CBaseAnimGraph;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace server {
		class CScriptedSequence : public CS2::server::CBaseEntity {
		public:
			PROPERTY(m_iszEntry,GlobalTypes::CUtlSymbolLarge* , 0x4a8);
			PROPERTY(m_iszPreIdle,GlobalTypes::CUtlSymbolLarge* , 0x4b0);
			PROPERTY(m_iszPlay,GlobalTypes::CUtlSymbolLarge* , 0x4b8);
			PROPERTY(m_iszPostIdle,GlobalTypes::CUtlSymbolLarge* , 0x4c0);
			PROPERTY(m_iszModifierToAddOnPlay,GlobalTypes::CUtlSymbolLarge* , 0x4c8);
			PROPERTY(m_iszNextScript,GlobalTypes::CUtlSymbolLarge* , 0x4d0);
			PROPERTY(m_iszEntity,GlobalTypes::CUtlSymbolLarge* , 0x4d8);
			PROPERTY(m_iszSyncGroup,GlobalTypes::CUtlSymbolLarge* , 0x4e0);
			PROPERTY(m_nMoveTo,modellib::ScriptedMoveTo_t , 0x4e8);
			PROPERTY(m_nMoveToGait,modellib::SharedMovementGait_t , 0x4ec);
			PROPERTY(m_nHeldWeaponBehavior,modellib::ScriptedHeldWeaponBehavior_t , 0x4f0);
			PROPERTY(m_nForcedCrouchState,client::ForcedCrouchState_t , 0x4f4);
			PROPERTY(m_bIsPlayingPreIdle,bool , 0x4f8);
			PROPERTY(m_bIsPlayingEntry,bool , 0x4f9);
			PROPERTY(m_bIsPlayingAction,bool , 0x4fa);
			PROPERTY(m_bIsPlayingPostIdle,bool , 0x4fb);
			PROPERTY(m_bDontRotateOther,bool , 0x4fc);
			PROPERTY(m_bIsRepeatable,bool , 0x4fd);
			PROPERTY(m_bShouldLeaveCorpse,bool , 0x4fe);
			PROPERTY(m_bStartOnSpawn,bool , 0x4ff);
			PROPERTY(m_bDisallowInterrupts,bool , 0x500);
			PROPERTY(m_bCanOverrideNPCState,bool , 0x501);
			PROPERTY(m_bDontTeleportAtEnd,bool , 0x502);
			PROPERTY(m_bHighPriority,bool , 0x503);
			PROPERTY(m_bHideDebugComplaints,bool , 0x504);
			PROPERTY(m_bContinueOnDeath,bool , 0x505);
			PROPERTY(m_bLoopPreIdleSequence,bool , 0x506);
			PROPERTY(m_bLoopActionSequence,bool , 0x507);
			PROPERTY(m_bLoopPostIdleSequence,bool , 0x508);
			PROPERTY(m_bSynchPostIdles,bool , 0x509);
			PROPERTY(m_bIgnoreLookAt,bool , 0x50a);
			PROPERTY(m_bIgnoreGravity,bool , 0x50b);
			PROPERTY(m_bDisableNPCCollisions,bool , 0x50c);
			PROPERTY(m_bKeepAnimgraphLockedPost,bool , 0x50d);
			PROPERTY(m_bDontAddModifiers,bool , 0x50e);
			PROPERTY(m_bDisableAimingWhileMoving,bool , 0x50f);
			PROPERTY(m_bIgnoreRotation,bool , 0x510);
			PROPERTY(m_flRadius,float32 , 0x514);
			PROPERTY(m_flRepeat,float32 , 0x518);
			PROPERTY(m_flPlayAnimFadeInTime,float32 , 0x51c);
			PROPERTY(m_flMoveInterpTime,float32 , 0x520);
			PROPERTY(m_flAngRate,float32 , 0x524);
			PROPERTY(m_flMoveSpeed,float32 , 0x528);
			PROPERTY(m_bWaitUntilMoveCompletesToStartAnimation,bool , 0x52c);
			PROPERTY(m_nNotReadySequenceCount,int32_t , 0x530);
			PROPERTY(m_startTime,entity2::GameTime_t , 0x534);
			PROPERTY(m_bWaitForBeginSequence,bool , 0x538);
			PROPERTY(m_saved_effects,int32_t , 0x53c);
			PROPERTY(m_savedFlags,int32_t , 0x540);
			PROPERTY(m_savedCollisionGroup,int32_t , 0x544);
			PROPERTY(m_bInterruptable,bool , 0x548);
			PROPERTY(m_sequenceStarted,bool , 0x549);
			PROPERTY(m_bPositionRelativeToOtherEntity,bool , 0x54a);
			PROPERTY(m_hTargetEnt,GlobalTypes::CHandle<server::CBaseEntity>, 0x54c);
			PROPERTY(m_hNextCine,GlobalTypes::CHandle<server::CScriptedSequence>, 0x550);
			PROPERTY(m_bThinking,bool , 0x554);
			PROPERTY(m_bInitiatedSelfDelete,bool , 0x555);
			PROPERTY(m_bIsTeleportingDueToMoveTo,bool , 0x556);
			PROPERTY(m_bAllowCustomInterruptConditions,bool , 0x557);
			PROPERTY(m_hForcedTarget,GlobalTypes::CHandle<server::CBaseAnimGraph>, 0x558);
			PROPERTY(m_bDontCancelOtherSequences,bool , 0x55c);
			PROPERTY(m_bForceSynch,bool , 0x55d);
			PROPERTY(m_bPreventUpdateYawOnFinish,bool , 0x55e);
			PROPERTY(m_bEnsureOnNavmeshOnFinish,bool , 0x55f);
			PROPERTY(m_onDeathBehavior,client::ScriptedOnDeath_t , 0x560);
			PROPERTY(m_ConflictResponse,server::ScriptedConflictResponse_t , 0x564);
			PROPERTY(m_OnBeginSequence,entity2::CEntityIOOutput , 0x568);
			PROPERTY(m_OnActionStartOrLoop,entity2::CEntityIOOutput , 0x580);
			PROPERTY(m_OnEndSequence,entity2::CEntityIOOutput , 0x598);
			PROPERTY(m_OnPostIdleEndSequence,entity2::CEntityIOOutput , 0x5b0);
			PROPERTY(m_OnCancelSequence,entity2::CEntityIOOutput , 0x5c8);
			PROPERTY(m_OnCancelFailedSequence,entity2::CEntityIOOutput , 0x5e0);
			PROPERTY_ARRAY(m_OnScriptEvent,entity2::CEntityIOOutput , 8 , 0x5f8);
			PROPERTY(m_matOtherToMain,GlobalTypes::CTransform , 0x6c0);
			PROPERTY(m_hInteractionMainEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x6e0);
			PROPERTY(m_iPlayerDeathBehavior,int32_t , 0x6e4);
			PROPERTY(m_bSkipFadeIn,bool , 0x6e8);
			S2_PAD(0x248);
		};
		//static_assert(sizeof(CS2::server::CScriptedSequence) == 0x6F0, "CScriptedSequence size should be 0x6F0");
	}
}
