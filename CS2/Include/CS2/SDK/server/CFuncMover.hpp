// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/server/CBaseModelEntity.hpp>
#include <SDK/server/Move_t.hpp>
#include <SDK/client/SolidType_t.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/entity2/CEntityIOOutput.hpp>
#include <SDK/server/OrientationUpdate_t.hpp>
#include <SDK/server/TransitionToPathNodeAction_t.hpp>
#include <SDK/server/FollowEntityDirection_t.hpp>



namespace CS2 {
	namespace server {
		class CPathMover;
		class CMoverPathNode;
		class CBaseEntity;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace server {
		class CFuncMover : public CS2::server::CBaseModelEntity {
		public:
			PROPERTY(m_iszPathName,GlobalTypes::CUtlSymbolLarge* , 0x7d8);
			PROPERTY(m_hPathMover,GlobalTypes::CHandle<server::CPathMover>, 0x7e0);
			PROPERTY(m_hPrevPathMover,GlobalTypes::CHandle<server::CPathMover>, 0x7e4);
			PROPERTY(m_iszPathNodeStart,GlobalTypes::CUtlSymbolLarge* , 0x7e8);
			PROPERTY(m_iszPathNodeEnd,GlobalTypes::CUtlSymbolLarge* , 0x7f0);
			PROPERTY(m_eMoveType,server::Move_t , 0x7f8);
			PROPERTY(m_bIsReversing,bool , 0x7fc);
			PROPERTY(m_vTarget,GlobalTypes::Vector , 0x800);
			PROPERTY(m_flStartSpeed,float32 , 0x80c);
			PROPERTY(m_flPathLocation,float32 , 0x810);
			PROPERTY(m_flT,float32 , 0x814);
			PROPERTY(m_nCurrentNodeIndex,int32_t , 0x818);
			PROPERTY(m_nPreviousNodeIndex,int32_t , 0x81c);
			PROPERTY(m_eSolidType,client::SolidType_t , 0x820);
			PROPERTY(m_bIsMoving,bool , 0x821);
			PROPERTY(m_flTimeToReachMaxSpeed,float32 , 0x824);
			PROPERTY(m_flDistanceToReachMaxSpeed,float32 , 0x828);
			PROPERTY(m_flTimeToReachZeroSpeed,float32 , 0x82c);
			PROPERTY(m_flDistanceToReachZeroSpeed,float32 , 0x830);
			PROPERTY(m_flTimeMovementStart,entity2::GameTime_t , 0x834);
			PROPERTY(m_flTimeMovementStop,entity2::GameTime_t , 0x838);
			PROPERTY(m_hStopAtNode,GlobalTypes::CHandle<server::CMoverPathNode>, 0x83c);
			PROPERTY(m_flPathLocationToBeginStop,float32 , 0x840);
			PROPERTY(m_iszStartForwardSound,GlobalTypes::CUtlSymbolLarge* , 0x848);
			PROPERTY(m_iszLoopForwardSound,GlobalTypes::CUtlSymbolLarge* , 0x850);
			PROPERTY(m_iszStopForwardSound,GlobalTypes::CUtlSymbolLarge* , 0x858);
			PROPERTY(m_iszStartReverseSound,GlobalTypes::CUtlSymbolLarge* , 0x860);
			PROPERTY(m_iszLoopReverseSound,GlobalTypes::CUtlSymbolLarge* , 0x868);
			PROPERTY(m_iszStopReverseSound,GlobalTypes::CUtlSymbolLarge* , 0x870);
			PROPERTY(m_iszArriveAtDestinationSound,GlobalTypes::CUtlSymbolLarge* , 0x878);
			PROPERTY(m_OnMovementEnd,entity2::CEntityIOOutput , 0x898);
			PROPERTY(m_bStartAtClosestPoint,bool , 0x8c0);
			PROPERTY(m_bStartAtEnd,bool , 0x8c1);
			PROPERTY(m_eOrientationUpdate,server::OrientationUpdate_t , 0x8c4);
			PROPERTY(m_flTimeStartOrientationChange,entity2::GameTime_t , 0x8c8);
			PROPERTY(m_flTimeToBlendToNewOrientation,float32 , 0x8cc);
			PROPERTY(m_flDurationBlendToNewOrientationRan,float32 , 0x8d0);
			PROPERTY(m_nOriginalOrientationIndex,int32_t , 0x8d4);
			PROPERTY(m_bCreateMovableNavMesh,bool , 0x8d8);
			PROPERTY(m_bAllowMovableNavMeshDockingOnEntireEntity,bool , 0x8d9);
			PROPERTY(m_OnNodePassed,entity2::CEntityIOOutput , 0x8e0);
			PROPERTY(m_iszOrientationMatchEntityName,GlobalTypes::CUtlSymbolLarge* , 0x908);
			PROPERTY(m_hOrientationMatchEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x910);
			PROPERTY(m_flTimeToTraverseToNextNode,float32 , 0x914);
			PROPERTY(m_vLerpToNewPosStartInPathEntitySpace,GlobalTypes::Vector , 0x918);
			PROPERTY(m_vLerpToNewPosEndInPathEntitySpace,GlobalTypes::Vector , 0x924);
			PROPERTY(m_flLerpToPositionT,float32 , 0x930);
			PROPERTY(m_flLerpToPositionDeltaT,float32 , 0x934);
			PROPERTY(m_OnLerpToPositionComplete,entity2::CEntityIOOutput , 0x938);
			PROPERTY(m_bIsPaused,bool , 0x960);
			PROPERTY(m_eTransitionedToPathNodeAction,server::TransitionToPathNodeAction_t , 0x964);
			PROPERTY(m_nDelayedTeleportToNode,int32_t , 0x968);
			PROPERTY(m_bIsVerboseLogging,bool , 0x96c);
			PROPERTY(m_hFollowEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x970);
			PROPERTY(m_flFollowDistance,float32 , 0x974);
			PROPERTY(m_flFollowMinimumSpeed,float32 , 0x978);
			PROPERTY(m_flCurFollowEntityT,float32 , 0x97c);
			PROPERTY(m_flCurFollowSpeed,float32 , 0x980);
			PROPERTY(m_strOrientationFaceEntityName,GlobalTypes::CUtlSymbolLarge* , 0x988);
			PROPERTY(m_hOrientationFaceEntity,GlobalTypes::CHandle<server::CBaseEntity>, 0x990);
			PROPERTY(m_OnStart,entity2::CEntityIOOutput , 0x998);
			PROPERTY(m_OnStartForward,entity2::CEntityIOOutput , 0x9c0);
			PROPERTY(m_OnStartReverse,entity2::CEntityIOOutput , 0x9e8);
			PROPERTY(m_OnStop,entity2::CEntityIOOutput , 0xa10);
			PROPERTY(m_OnStopped,entity2::CEntityIOOutput , 0xa38);
			PROPERTY(m_bNextNodeReturnsCurrent,bool , 0xa60);
			PROPERTY(m_bStartedMoving,bool , 0xa61);
			PROPERTY(m_eFollowEntityDirection,server::FollowEntityDirection_t , 0xa80);
			S2_PAD(0x2B0);
		};
		//static_assert(sizeof(CS2::server::CFuncMover) == 0xA88, "CFuncMover size should be 0xA88");
	}
}
