// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once
#include <utility>
#include <cstdint>
#include <cfloat>
#include <string_view>
#include <vector>
#include <map>
#include <GlobalData/Include.h>
#include <Source2/CBaseHandle.h>
#include <Source2/CUtlVector.h>
#include <Source2/CUtlString.h>
#include <Source2/CStrongHandle.h>
#include <Source2/CUtlSymbolLarge.h>
#include <Math/Vector.h>
#include <Math/Matrix.h>
#include <Math/QAngle.h>
#include <Math/Quaternion.h>

using float32 = float;
using float64 = double;
using int8 = int8_t;
using int16 = int16_t;
using int32 = int32_t;
using int64 = int64_t;
using uint8 = uint8_t;
using uint16 = uint16_t;
using uint32 = uint32_t;
using uint64 = uint64_t;

#ifndef S2_PAD
#define S2_PAD_INSERT(x, y) x ## y
#define S2_PAD_DEFINE(x, y) S2_PAD_INSERT(x, y)
#define S2_PAD(size) char S2_PAD_DEFINE(padding_, __LINE__)[size]
#endif




namespace Client {
	template <typename T>
	struct C_UtlVectorEmbeddedNetworkVar {

	};


	template <typename T>
	struct C_NetworkUtlVectorBase {

	};
}

namespace GlobalTypes {
	using Vector2D /*Vector2D*/ = char[0x8]; //  Schema_Atomic
	using CUtlString /*CUtlString*/ = ::Source2::CUtlString; // char[0x8]; //  Schema_Atomic
	using CGlobalSymbol = uintptr_t;
	// using CGlobalSymbol /*CGlobalSymbol*/ = char[0x8]; //  Schema_Atomic
	using CUtlBinaryBlock /*CUtlBinaryBlock*/ = char[0x10]; //  Schema_Atomic

	template <typename T>
	struct C_NetworkUtlVectorBase {

	};

	template <typename T>
	struct C_UtlVectorEmbeddedNetworkVar {

	};
	template <typename T>
	struct CStrongHandleCopyable {
		char pad[0x8];

	};
	// template <typename T>
	// using CStrongHandleCopyable /*CStrongHandleCopyable< InfoForResourceTypeIMaterial2 >*/ = char[0x8]; //  Schema_Atomic


	struct CTransform {
		char pad[0x20];
	};
	// using CTransform /*CTransform*/ = char[0x20]; //  Schema_Atomic
	using VectorAligned /*VectorAligned*/ = char[0x10]; //  Schema_Atomic
	struct Color {
		char pad[0x4];
	};


	template <typename T1>
	using CStrongHandle = ::Source2::CStrongHandle<T1>;
	// template <typename T>
	// using CStrongHandle /*CStrongHandle< InfoForResourceTypeIMaterial2 >*/ = char[0x8]; //  Schema_Atomic

	// using Color /*Color*/ = char[0x4]; //  Schema_Atomic
	using Vector /*Vector*/ = ::Vector;// char[0xc]; //  Schema_Atomic
	using Quaternion /*Quaternion*/ = ::Quaternion; // char[0x10]; //  Schema_Atomic
	using CAnimVariant /*CAnimVariant*/ = char[0x11]; //  Schema_Atomic
	using QAngle /*QAngle*/ = ::QAngle_t; // char[0xc]; //  Schema_Atomic
	using KeyValues3 /*KeyValues3*/ = char[0x10]; //  Schema_Atomic

	struct KeyValues {
		char pad[0x10];
	};
	// using KeyValues3 /*KeyValues3*/ = char[0x10]; //  Schema_Atomic
	using CColorGradient /*CColorGradient*/ = char[0x18]; //  Schema_Atomic

	struct Vector4D {
		float x; float y; float z; float w;
	};
	// using Vector4D /*Vector4D*/ = char[0x10]; //  Schema_Atomic
	using matrix3x4_t /*matrix3x4_t*/ = ::Matrix3x4_t;// char[0x30]; //  Schema_Atomic
	using CEntityIndex /*CEntityIndex*/ = uint32_t; // char[0x4]; //  Schema_Atomic
	using matrix3x4a_t /*matrix3x4a_t*/ = char[0x30]; //  Schema_Atomic
	using CBufferString /*CBufferString*/ = char[0x10]; //  Schema_Atomic
	using CModelAnimNameWithDeltas /*CModelAnimNameWithDeltas*/ = char[0x8]; //  Schema_Atomic
	using CPiecewiseCurve /*CPiecewiseCurve*/ = char[0x40]; //  Schema_Atomic
	using PulseSymbol_t /*PulseSymbol_t*/ = char[0x10]; //  Schema_Atomic
	using CPulseValueFullType /*CPulseValueFullType*/ = char[0x18]; //  Schema_Atomic
	using CKV3MemberNameWithStorage /*CKV3MemberNameWithStorage*/ = char[0x38]; //  Schema_Atomic
	using CGlobalSymbolCaseSensitive /*CGlobalSymbolCaseSensitive*/ = char[0x8]; //  Schema_Atomic
	using CKV3MemberNameSet /*CKV3MemberNameSet*/ = char[0x10]; //  Schema_Atomic
	using HSCRIPT /*HSCRIPT*/ = char[0x8]; //  Schema_Atomic

	struct CUtlStringToken {
		char data[0x4];
	};

	// using CUtlStringToken /*CUtlStringToken*/ = char[0x4]; //  Schema_Atomic
	using CUtlSymbolLarge /*CUtlSymbolLarge*/ = ::Source2::CUtlSymbolLarge; // char[0x8]; //  Schema_Atomic
	template <typename T1>
	using CUtlVector /*CUtlVector*/ = ::Source2::CUtlVector<T1>; //  char[0x18]; //  Schema_Atomic
	using QuaternionStorage /*QuaternionStorage*/ = char[0x10]; //  Schema_FixedArray
	using FourVectors /*FourVectors*/ = char[0x30]; //  Schema_FixedArray
	template <typename T>
	using CHandle /*CHandle*/ = ::Source2::CBaseHandle<T>; //  Schema_Atomic
	// using VectorWS /*VectorWS*/ = char[0xc]; //  Schema_Atomic
	struct VectorWS {
		char data[0xC];
	};
	struct CNetworkedQuantizedFloat {
		char pad[0x18];
	};
	struct CSplitScreenSlot {
		char pad[0x4];
	};

	// using CNetworkedQuantizedFloat /*CNetworkedQuantizedFloat*/ = char[0x18]; //  Schema_Atomic
	// using CSplitScreenSlot /*CSplitScreenSlot*/ = char[0x4]; //  Schema_Atomic
	using CAttachmentNameSymbolWithStorage /*CAttachmentNameSymbolWithStorage*/ = char[0x20]; //  Schema_Atomic
	// using CEntityHandle /*CEntityHandle*/ = char[0x4]; //  Schema_Atomic
	using CEntityHandle /*CEntityHandle*/ = uint32_t; //  Schema_Atomic
	// using CTransformWS /*CTransformWS*/ = char[0x20]; //  Schema_Atomic
	struct CTransformWS {
		char data[0x20];
	};
	using CUtlSymbol /*CUtlSymbol*/ = char[0x2]; //  Schema_Atomic
	using WorldGroupId_t = uint32_t;
	// using WorldGroupId_t /*WorldGroupId_t*/ = char[0x4]; //  Schema_Atomic
	// using WorldGroupId_t /*WorldGroupId_t*/ = char[0x4]; //  Schema_Atomic
	using CPlayerSlot /*CPlayerSlot*/ = char[0x4]; //  Schema_Atomic
	using CAnimGraphTagRef /*CAnimGraphTagRef*/ = char[0x18]; //  Schema_Atomic
	using CParticleNamedValueRef /*CParticleNamedValueRef*/ = char[0x40]; //  Schema_Atomic
	using Range_t /*Range_t*/ = char[0x8]; //  Schema_Atomic
	using CResourceName /*CResourceName*/ = char[0xe0]; //  Schema_Atomic
	using fltx4 /*fltx4*/ = char[0x10]; //  Schema_Atomic
	using CUtlVectorSIMDPaddedVector /*CUtlVectorSIMDPaddedVector*/ = char[0x18]; //  Schema_Atomic
	using CSmartPropAttributeBool /*CSmartPropAttributeBool*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeVector /*CSmartPropAttributeVector*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeAngles /*CSmartPropAttributeAngles*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeFloat /*CSmartPropAttributeFloat*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeInt /*CSmartPropAttributeInt*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeVector2D /*CSmartPropAttributeVector2D*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeModelName /*CSmartPropAttributeModelName*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeMaterialGroup /*CSmartPropAttributeMaterialGroup*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeSurfaceProperty /*CSmartPropAttributeSurfaceProperty*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeColor /*CSmartPropAttributeColor*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropVariableComparison /*CSmartPropVariableComparison*/ = char[0x20]; //  Schema_Atomic
	using CSmartPropAttributeMaterialName /*CSmartPropAttributeMaterialName*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeStateName /*CSmartPropAttributeStateName*/ = char[0x40]; //  Schema_Atomic
	using CSmartPropAttributeVariableValue /*CSmartPropAttributeVariableValue*/ = char[0x40]; //  Schema_Atomic
	using CModelMaterialGroupName /*CModelMaterialGroupName*/ = char[0x8]; //  Schema_Atomic
	using RotationVector /*RotationVector*/ = char[0xc]; //  Schema_Atomic
	using RadianEuler /*RadianEuler*/ = char[0xc]; //  Schema_Atomic
	using DegreeEuler /*DegreeEuler*/ = char[0xc]; //  Schema_Atomic
	using CUtlStringTokenWithStorage /*CUtlStringTokenWithStorage*/ = char[0x18]; //  Schema_Atomic



}